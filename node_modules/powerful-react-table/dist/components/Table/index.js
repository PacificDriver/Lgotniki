"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Row = exports.PowerTableInner = exports.PowerTable = exports.Cell = void 0;
var _react = _interopRequireWildcard(require("react"));
var _useTable = require("../useTable");
var _resizeble = _interopRequireDefault(require("./resizeble"));
var _filter = _interopRequireDefault(require("./filter"));
var _sortable = _interopRequireDefault(require("./sortable"));
var _setTableColumnWidths = _interopRequireDefault(require("./setTableColumnWidths"));
var _utils = require("../../_utils");
var _Pagination = _interopRequireDefault(require("../Pagination"));
var _DropdownMenu = _interopRequireDefault(require("../DropdownMenu"));
var _Export = _interopRequireDefault(require("../Export"));
var _FilteredItems = _interopRequireDefault(require("../FilteredItems"));
var _fi = require("react-icons/fi");
var _tb = require("react-icons/tb");
require("./Table.scss");
var _Filter = _interopRequireDefault(require("../Filter"));
var _Checkbox = _interopRequireDefault(require("../Checkbox"));
var _Input = _interopRequireDefault(require("../Input"));
var _localeConfig = require("../../localeConfig");
var _tableProvider = _interopRequireDefault(require("../tableProvider"));
var _jsxRuntime = require("react/jsx-runtime");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
const PowerTableInner = _ref => {
  let {
    children,
    title = "",
    tableId = "",
    columns: headers,
    checkboxSelection = false,
    onSelected,
    className = "",
    disableColumnSorting = false,
    disableLastColumnSorting = false,
    disableColumnResize = false,
    disableColumnFilter = false,
    disableColumnMenu = false,
    disableSearchFilter = false,
    disableExport = false,
    disableAutosize = false,
    columnHeaderHeight = null,
    hideFooter = false,
    pageSizeOptions = [],
    localeText = {},
    actionButtons // elementos html
  } = _ref;
  const [columns, setColumns] = (0, _react.useState)(headers);
  const [paginationInfo, setPaginationInfo] = (0, _react.useState)({
    itemsPerPage: 10,
    offset: 0
  });
  const [originalData, setOriginalData] = (0, _react.useState)([]);
  const [renderingData, setRenderingData] = (0, _react.useState)([]);
  const [filteredData, setFilteredData] = (0, _react.useState)([]);
  const [searchQuery, setSearchQuery] = (0, _react.useState)("");
  const tableRef = (0, _react.useRef)(null);
  const theadRef = (0, _react.useRef)(null);
  const tbodyRef = (0, _react.useRef)(null);
  const rowsRef = (0, _react.useRef)([]);
  const {
    filterByText,
    filterByOption,
    filterByDate,
    filterByBetween
  } = (0, _filter.default)();
  const {
    onMouseDown,
    onMouseMove,
    onMouseUp,
    loadTableSettings,
    setsFirstColumnToFixed,
    dispatchScroll,
    pressed
  } = (0, _resizeble.default)(tableRef, theadRef, columns, tableId);
  const {
    sortable
  } = (0, _sortable.default)();
  const {
    setDisableColumnSorting,
    setDisableColumnResize,
    setDisableColumnFilter,
    setColumnWidths,
    setData,
    setTableId,
    searchFilter,
    setSearchFilter,
    setHiddenColumnIds,
    hiddenColumnIds
  } = (0, _useTable.useTable)();
  const localeTextConstants = (0, _localeConfig.getLocaleText)();
  (0, _react.useEffect)(() => {
    setDisableColumnSorting(disableColumnSorting);
    setDisableColumnResize(disableColumnResize);
    setDisableColumnFilter(disableColumnFilter);
    setTableId(tableId);
    if (pageSizeOptions?.length) {
      setPaginationInfo({
        ...pagination,
        itemsPerPage: pageSizeOptions[0]
      });
    }
    if (Object.keys(localeText || [])?.length > 0) {
      (0, _localeConfig.configureGlobalLocaleText)({
        ...localeText
      });
    }
  }, []);
  (0, _react.useEffect)(() => {
    const storage = localStorage.getItem("__magnunTablePreferences");
    const filtersStorage = storage ? JSON.parse(storage)?.filters?.[tableId] : [];
    const filters = filtersStorage ? Object.values(filtersStorage) : [];
    setSearchFilter([...filters]);
  }, [tableId]);
  (0, _react.useEffect)(() => {
    applyFilters({
      filters: searchFilter
    });
  }, [searchFilter]);
  (0, _react.useEffect)(() => {
    const savedFilter = getStorage("__magnunTablePreferences")?.filters?.[tableId];
    headers?.forEach((head, index) => {
      head.sortType = "default";
      head.filtered = false;
      head.position = index;
      head.hasFilter = Object.keys(savedFilter || [])?.includes(head?.name?.toUpperCase());
      if (head?.filter) head.filter.position = index;
    });
    setColumns([...headers]);
  }, [paginationInfo]);
  (0, _react.useEffect)(() => {
    setColumnWidths((0, _setTableColumnWidths.default)(children, headers, null, disableAutosize));
    setTableId(tableId);
    setOriginalData(_react.default.Children.toArray(children));
    setData(_react.default.Children.toArray(children));
    if (tableRef?.current) {
      tableRef.current.addEventListener("scroll", () => {
        setsFirstColumnToFixed(tableRef.current.scrollLeft);
      });
    }
  }, [children]);
  (0, _react.useEffect)(() => {
    const table = tableRef?.current;
    document.body.addEventListener("scroll", closeAllDropdowns);
    table.addEventListener("scroll", closeAllDropdowns);
    return () => {
      document.body.removeEventListener("scroll", closeAllDropdowns);
      table.removeEventListener("scroll", closeAllDropdowns);
    };
  }, []);
  const applyFilters = (0, _react.useCallback)(_ref2 => {
    let {
      filters,
      result = false
    } = _ref2;
    if (!filters?.length) {
      const childrenArray = originalData;
      let values;
      const endOffset = paginationInfo?.offset + paginationInfo?.itemsPerPage;
      values = !hideFooter ? childrenArray.slice(paginationInfo.offset, endOffset) : childrenArray;
      setFilteredData([]);
      updateRendering([...values]);
      return;
    }
    let filtered = _react.default.Children.toArray(children);
    filters.forEach(value => {
      if (value.type === "text") {
        filtered = filterByText(value, filtered);
      }
      if (value.type === "between") {
        filtered = filterByBetween(value, filtered);
      }
      if (value.type === "option") {
        filtered = filterByOption(value, filtered);
      }
      if (value.type === "date") {
        filtered = filterByDate(value, filtered);
      }
    });
    setFilteredData([...filtered]);
    if (result) return filtered;
    updateRendering([...filtered]);
  }, [filterByText, filterByBetween, filterByOption, filterByDate, loadTableSettings]);
  const memoizedRenderedData = (0, _react.useMemo)(() => {
    if (children?.length < 1) return;
    let childrenArray = _react.default.Children.toArray(children);
    if (searchQuery) {
      const normalizedQuery = (0, _utils.removeAccents)(searchQuery.toLowerCase());
      return children.filter(row => row.props.children.some(cell => (0, _utils.removeAccents)((0, _utils.findInnerText)(cell).toLowerCase()).includes(normalizedQuery)));
    }
    const endOffset = paginationInfo?.offset + paginationInfo?.itemsPerPage;
    if (searchFilter?.length) {
      childrenArray = applyFilters({
        filters: searchFilter,
        result: true
      });
    }
    return !hideFooter ? childrenArray.slice(paginationInfo.offset, endOffset) : childrenArray;
  }, [children, hideFooter, paginationInfo, searchFilter, searchQuery]);
  (0, _react.useEffect)(() => {
    updateRendering(memoizedRenderedData);
  }, [memoizedRenderedData]);
  const onSortChange = (0, _react.useCallback)((column, index) => {
    const updateSortingType = (column, index, type) => {
      headers.forEach((head, key) => {
        head.sortType = "default";
        if (key === index) head.sortType = type;
      });
      setColumns([...headers]);
      updateRendering(sortable(column, renderingData, originalData));
    };
    switch (column.sortType) {
      case "default":
        updateSortingType(column, index, "down");
        break;
      case "down":
        updateSortingType(column, index, "up");
        break;
      default:
        updateSortingType(column, index, "default");
        break;
    }
  }, [sortable, originalData, headers, renderingData]);
  const getStorage = key => {
    const saved = localStorage.getItem(key);
    return saved ? JSON.parse(saved) : null;
  };
  const updateRendering = (0, _react.useCallback)(collection => {
    if (!collection?.length) return;
    setRenderingData([...collection]);
    setsFirstColumnToFixed(tableRef.current.scrollLeft);
    setTimeout(() => {
      loadTableSettings();
      if (tableRef?.current) {
        const rowsArray = Array.from(tableRef.current.getElementsByTagName("tr"));
        rowsArray.shift();
        rowsRef.current = rowsArray;
      }
    }, 5);
  }, [setsFirstColumnToFixed]);
  const checkboxChanges = values => onSelected?.(values?.sort());
  const closeAllDropdowns = () => {
    const savedFilter = getStorage("__magnunTablePreferences")?.filters?.[tableId];
    const items = columns;
    items?.forEach(item => {
      item.filtered = false;
      item.hasFilter = Object.keys(savedFilter || [])?.includes(item?.name?.toUpperCase());
    });
    setColumns([...items]);
  };
  const removeFilter = (0, _react.useCallback)(remove => {
    if (remove) {
      const savedFilter = getStorage("__magnunTablePreferences")?.filters?.[tableId];
      const updatedColumns = columns.map(item => ({
        ...item,
        hasFilter: Object.keys(savedFilter || [])?.includes(item?.name?.toUpperCase())
      }));
      setColumns(updatedColumns);
    }
  }, [columns, tableId]);
  const getData = () => rowsRef?.current;
  const handleColumnVisibility = (value, checked) => {
    const values = headers;
    const index = values?.findIndex(header => header?.name === value);
    if (index !== -1) {
      setHiddenColumnIds(prevState => prevState.includes(index) ? prevState.filter(id => id !== index) : [...prevState, index]);
    }
  };
  return /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
    className: `powerful-react-table-container ${className} ${!title && "powerful-react-table-container--no-border"}`,
    onMouseUp: onMouseUp,
    id: "powerful-react-table",
    children: [(title || !disableSearchFilter || !disableColumnMenu || !disableExport || actionButtons) && /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: "powerful-react-table-container__header",
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
        className: "powerful-react-table-container__header--title",
        children: title
      }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: `d-flex align-items-center ${title ? "justify-content-end" : "justify-content-between"} gap-1 ${!title ? "w-100" : "w-60"}`,
        children: [!disableSearchFilter && /*#__PURE__*/(0, _jsxRuntime.jsx)(_Input.default, {
          styles: {
            width: "220px",
            height: "34px"
          },
          placeholder: localeTextConstants.toolbarQuickFilterPlaceholder,
          iconBefore: /*#__PURE__*/(0, _jsxRuntime.jsx)(_fi.FiSearch, {}),
          onChange: value => setSearchQuery(value)
        }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          className: "d-flex align-items-center justify-content-end gap-1",
          children: [!disableColumnMenu && /*#__PURE__*/(0, _jsxRuntime.jsx)(_DropdownMenu.default, {
            options: headers?.map((header, index) => ({
              name: /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
                children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_Checkbox.default, {
                  label: header?.name,
                  value: header?.name,
                  isChecked: hiddenColumnIds?.includes(index) ? false : true,
                  onChange: _ref3 => {
                    let {
                      value,
                      checked
                    } = _ref3;
                    return handleColumnVisibility(value, checked);
                  }
                })
              }),
              value: header?.name
            })),
            trigger: /*#__PURE__*/(0, _jsxRuntime.jsxs)(_jsxRuntime.Fragment, {
              children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_tb.TbColumns3, {}), " ", localeTextConstants.toolbarColumns]
            })
          }), !disableExport && /*#__PURE__*/(0, _jsxRuntime.jsx)(_Export.default, {
            data: getData(),
            headers: columns,
            title: title,
            tableRef: tableRef
          }), actionButtons && actionButtons.map((button, index) => /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
            className: "d-flex align-items-center gap-1",
            children: button
          }, index))]
        })]
      })]
    }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_FilteredItems.default, {}), /*#__PURE__*/(0, _jsxRuntime.jsxs)("table", {
      className: `content-table ${pressed ? "disable__selection" : ""} ${!title && "content-table--apply-border"}`,
      ref: tableRef,
      onMouseMove: event => onMouseMove(event),
      id: tableId,
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(Thead, {
        columns: columns,
        createRef: theadRef,
        checkboxSelection: checkboxSelection,
        totalItems: filteredData?.length || children?.length,
        onMouseDown: _ref4 => {
          let {
            event,
            index
          } = _ref4;
          return onMouseDown(event, index);
        },
        onSort: _ref5 => {
          let {
            column,
            index,
            type
          } = _ref5;
          return onSortChange(column, index);
        },
        onChange: values => checkboxChanges(values),
        tableRef: tableRef,
        tableId: tableId,
        columnHeaderHeight: columnHeaderHeight,
        disableLastColumnSorting: disableLastColumnSorting
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("tbody", {
        className: `content-table__content`,
        ref: tbodyRef,
        children: renderingData
      })]
    }), !renderingData?.length && /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
      className: "no__data",
      children: "Dados n\xE3o encontrados."
    }), !hideFooter && /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
      className: "mt-1 pr-3",
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_Pagination.default, {
        totalItems: filteredData?.length || children?.length,
        totalPerPage: paginationInfo?.itemsPerPage,
        onChangePage: _ref6 => {
          let {
            pagination: info
          } = _ref6;
          setPaginationInfo({
            ...info
          });
          dispatchScroll();
        },
        pageSizeOptions: pageSizeOptions
      })
    })]
  });
};
exports.PowerTableInner = PowerTableInner;
const PowerTable = props => {
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_tableProvider.default, {
    children: /*#__PURE__*/(0, _jsxRuntime.jsx)(PowerTableInner, {
      ...props
    })
  });
};
exports.PowerTable = PowerTable;
const Row = _ref7 => {
  let {
    children,
    className = '',
    id,
    onClick,
    onDoubleClick
  } = _ref7;
  const {
    columnWidths
  } = (0, _useTable.useTable)();
  return /*#__PURE__*/(0, _jsxRuntime.jsx)("tr", {
    className: `table-line-container ${className}`,
    "tr-key": id,
    onClick: () => onClick?.(),
    onDoubleClick: () => onDoubleClick?.(),
    children: _react.default.Children.map(children, (child, index) => /*#__PURE__*/_react.default.cloneElement(child, {
      columnWidth: columnWidths[index],
      id
    }))
  });
};
exports.Row = Row;
const Cell = _ref8 => {
  let {
    children,
    className = [],
    columnWidth,
    id = null
  } = _ref8;
  const {
    checkbox,
    selected,
    setSelected,
    hiddenColumnIds
  } = (0, _useTable.useTable)();
  const cellRef = (0, _react.useRef)(null);
  const [cellIndex, setCellIndex] = (0, _react.useState)(null);
  const [isChecked, setIsChecked] = (0, _react.useState)(false);
  (0, _react.useEffect)(() => {
    setTimeout(() => {
      setCellIndex(cellRef?.current?.cellIndex);
    }, 10);
  }, []);
  (0, _react.useEffect)(() => {
    setIsChecked(selected?.length && selected.includes(id) ? true : false);
  }, [selected]);
  const onChecked = (checked, event) => {
    const tr = event.target.closest("tr");
    setIsChecked(checked);
    if (checked) {
      tr.classList.add("checked");
      setSelected([...selected, id]);
      return;
    }
    const filtred = selected?.filter(value => value !== id);
    setSelected([...filtred]);
    tr.classList.remove("checked");
  };
  const extractChildrenValues = children => {
    if (!children) {
      return [];
    }
    if (!Array.isArray(children)) {
      return [children];
    }
    const values = [];
    children?.forEach(child => {
      if (child?.props && child?.props?.children) {
        values.push(...extractChildrenValues(child?.props?.children));
      } else {
        values.push(child);
      }
    });
    return values;
  };
  const getChildrenValues = children => {
    if (!children) {
      return [];
    }
    if (!Array.isArray(children)) {
      return [children];
    }
    return children?.map(child => {
      if (child?.props && child?.props?.children) {
        return extractChildrenValues(child?.props?.children);
      } else {
        return child;
      }
    }).flat();
  };
  return /*#__PURE__*/(0, _jsxRuntime.jsxs)("td", {
    className: `table-line-td ${className}`,
    ref: cellRef,
    style: {
      ...(columnWidth && {
        width: columnWidth
      }),
      ...(hiddenColumnIds.includes(cellIndex) && {
        display: "none"
      })
    },
    children: [checkbox && cellIndex === 0 && /*#__PURE__*/(0, _jsxRuntime.jsx)(_Checkbox.default, {
      onChange: _ref9 => {
        let {
          checked,
          event
        } = _ref9;
        return onChecked(checked, event);
      },
      isChecked: isChecked
    }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
      className: `td-item ${className}`,
      children: (0, _utils.insertChildrenToDOM)(_react.default.Children.toArray(getChildrenValues(children)))
    })]
  });
};
exports.Cell = Cell;
const Thead = _ref10 => {
  let {
    columns: headers,
    createRef,
    checkboxSelection,
    totalItems,
    onMouseDown,
    onSort,
    onChange,
    tableRef,
    tableId,
    columnHeaderHeight,
    disableLastColumnSorting
  } = _ref10;
  const [cleanFilter, setCleanFilter] = (0, _react.useState)(false);
  const [columns, setColumns] = (0, _react.useState)(headers);
  const [indeterminate, setIndeterminate] = (0, _react.useState)(false);
  const [isChecked, setIsChecked] = (0, _react.useState)(false);
  const {
    setCheckbox,
    selected,
    setSelected,
    setSearchFilter,
    columnWidths,
    disableColumnSorting,
    disableColumnResize,
    disableColumnFilter,
    openDropdown,
    setOpenDropdown,
    setSelectedHeader,
    hiddenColumnIds
  } = (0, _useTable.useTable)();
  const inputRef = (0, _react.useRef)(null);
  const thRef = (0, _react.useRef)([]);
  const filterRef = (0, _react.useRef)([]);
  (0, _react.useEffect)(() => {
    setCheckbox(checkboxSelection || false);
  }, []);
  (0, _react.useEffect)(() => {
    onChange?.(selected);
    if (selected?.length && selected?.length < totalItems) {
      setIndeterminate(true);
      setIsChecked(true);
    }
    if (selected?.length && selected?.length === totalItems) {
      setIsChecked(true);
      setIndeterminate(false);
    }
    if (!selected?.length) {
      setIndeterminate(false);
      setIsChecked(false);
    }
    if (selected?.length < totalItems && inputRef?.current) {
      inputRef.current.checked = false;
    }
  }, [selected]);
  (0, _react.useEffect)(() => {
    const storage = localStorage.getItem("__magnunTablePreferences");
    const filtersStorage = storage ? JSON.parse(storage)?.filters?.[tableId] : null;
    const filters = [];
    if (filtersStorage) {
      for (const key in filtersStorage) {
        filters.push(filtersStorage[key]);
      }
    }
    setSearchFilter([...filters]);
  }, [cleanFilter]);
  const markAll = (event, checked) => {
    const elements = createRef?.current?.offsetParent?.lastChild?.querySelectorAll("[type=checkbox]");
    const childrens = createRef?.current?.offsetParent?.lastChild?.childNodes;
    if (selected?.length && selected?.length < totalItems) {
      event.target.checked = false;
      setSelected([]);
      elements?.forEach(element => {
        element.checked = false;
      });
      childrens?.forEach(children => children.classList.remove(`checked`));
      return;
    }
    elements?.forEach(element => {
      element.checked = false;
    });
    if (checked) {
      const keys = [];
      childrens?.forEach(children => {
        children.classList.add(`checked`);
        keys.push(Number(children?.getAttribute("tr-key")));
      });
      setSelected([...keys]);
      setIsChecked(keys?.length === totalItems);
      setIndeterminate(false);
      return;
    }
    setSelected([]);
    childrens?.forEach(children => children.classList.remove(`checked`));
  };
  const handleDisplayFilter = index => {
    const items = columns;
    items?.forEach(item => item.filtered = false);
    items[index].filtered = true;
    setColumns([...items]);
    setOpenDropdown(true);
  };
  const handleMouseOver = index => {
    const width = thRef?.current[index]?.clientWidth;
    const span = thRef?.current[index]?.firstElementChild?.firstElementChild;
    const sortButton = thRef?.current[index]?.firstElementChild?.lastElementChild;
    if (!span) return;
    if (width < 120) {
      span.style.width = "40px";
      span.style.maxWidth = "40px";
      span.classList.add("column-info__name--ellipsi");
      sortButton.style.gap = "0";
      sortButton.style.marginLeft = "-8px";
    }
  };
  const handleMouseOut = index => {
    const width = thRef?.current[index]?.clientWidth;
    const span = thRef?.current[index]?.firstElementChild?.firstElementChild;
    const sortButton = thRef?.current[index]?.firstElementChild?.lastElementChild;
    if (width < 120) {
      span.style.width = `${columnWidths[index]}px`;
      span.style.maxWidth = `${columnWidths[index]}px`;
      span.style.textAlign = "left";
      span.classList.remove("column-info__name--ellipsi");
      sortButton.style.gap = "4px";
      sortButton.style.marginLeft = "unset";
    }
  };
  return /*#__PURE__*/(0, _jsxRuntime.jsx)("thead", {
    className: `content-table__header`,
    ref: createRef,
    children: /*#__PURE__*/(0, _jsxRuntime.jsx)("tr", {
      className: "header__item",
      identifier: tableId,
      style: {
        ...(columnHeaderHeight && {
          height: `${columnHeaderHeight}px`
        })
      },
      children: columns?.map((column, index) => {
        const isLastColumn = index === columns.length - 1;
        return /*#__PURE__*/(0, _jsxRuntime.jsxs)("th", {
          className: `d-flex align-items-center`,
          "data-name": column.name,
          style: {
            ...(columnWidths[index] && {
              width: columnWidths[index]
            }),
            ...(columnHeaderHeight && {
              height: `${columnHeaderHeight}px`
            }),
            ...(hiddenColumnIds.includes(index) && {
              display: 'none'
            })
          },
          onClick: () => setSelectedHeader(index),
          ref: element => thRef.current[index] = element,
          onMouseOver: () => handleMouseOver(index),
          onMouseOut: () => handleMouseOut(index),
          children: [index === 0 && checkboxSelection && /*#__PURE__*/(0, _jsxRuntime.jsx)(_Checkbox.default, {
            onChange: _ref11 => {
              let {
                checked,
                event
              } = _ref11;
              return markAll(event, checked);
            },
            isIndeterminate: indeterminate ? true : false,
            isChecked: isChecked
          }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("span", {
            className: `column-info`,
            "data-type": "name",
            children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
              className: "column-info__name",
              children: column?.name
            }), !disableColumnSorting && !(disableLastColumnSorting && isLastColumn) && /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
              className: `column-info__sort-icon ${["down", "up"]?.includes(column?.sortType) && "column-info__sort-icon--down-up"}`,
              onClick: () => onSort({
                column,
                index
              }),
              "data-type": "sorting",
              children: ["down", "default"]?.includes(column?.sortType) ? /*#__PURE__*/(0, _jsxRuntime.jsx)(_fi.FiArrowUp, {}) : /*#__PURE__*/(0, _jsxRuntime.jsx)(_fi.FiArrowDown, {})
            })]
          }), !disableColumnFilter && column?.dataType && /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
            className: `filter-options ${openDropdown && column?.filtered && "filter-options--visible"}`,
            onClick: () => handleDisplayFilter(index),
            ref: element => filterRef.current[index] = element,
            children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_fi.FiChevronDown, {})
          }), openDropdown && column?.filtered && /*#__PURE__*/(0, _jsxRuntime.jsx)(_Filter.default, {
            column: column,
            headers: headers,
            createRef: filterRef?.current[index]
          }), !disableColumnResize && /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
            className: "column-resizing",
            onMouseDown: event => onMouseDown({
              event,
              index
            }),
            "data-type": "resizable"
          })]
        }, index);
      })
    })
  });
};
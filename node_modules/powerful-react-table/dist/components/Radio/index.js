"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = Radio;
var _react = _interopRequireWildcard(require("react"));
var _uuid = require("uuid");
var _RadioModule = _interopRequireDefault(require("./Radio.module.scss"));
var _jsxRuntime = require("react/jsx-runtime");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function Radio(_ref) {
  let {
    options: items,
    disabled,
    direction,
    selected,
    onChange,
    element
  } = _ref;
  const inputRef = (0, _react.useRef)(null);
  const [selectedOption, setSelectedOption] = (0, _react.useState)(null);
  const [uuid, setUuid] = (0, _react.useState)([]);
  const [options, setOptions] = (0, _react.useState)([]);
  (0, _react.useEffect)(() => {
    if (!items?.length) return;
    const list = [];
    for (let index = 0; index < items.length; index++) {
      items[index].disabled = false;
      list.push(`radio-${(0, _uuid.v4)()}`);
    }
    setOptions([...items]);
    setUuid([...list]);
  }, [items]);
  (0, _react.useEffect)(() => {
    const index = options?.findIndex(option => option.value === selected);
    if (index !== -1) setSelectedOption(index);
  }, [options, selected]);
  (0, _react.useEffect)(() => {
    items?.forEach(option => {
      if (disabled?.includes(option?.value)) option.disabled = true;
    });
    setOptions([...items]);
  }, [disabled, items]);
  const handleSelection = (index, option) => {
    if (option?.disabled) return;
    setSelectedOption(index);
    onChange?.(option?.value);
  };
  return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
    className: _RadioModule.default['radio-container'],
    style: {
      flexDirection: direction || 'column',
      ...(direction === 'row' && {
        gap: '16px'
      })
    },
    children: options?.map((option, index) => /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: `d-flex align-items-start flex-column ${option?.disabled ? _RadioModule.default['radio-container--disabled'] : ''}`,
      children: [option?.label && /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: "d-flex align-items-center",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
          type: "radio",
          ref: inputRef,
          id: uuid?.[index] || window.btoa(option?.label),
          className: _RadioModule.default['radio-container__radio'],
          value: option?.value,
          checked: selectedOption === index,
          onChange: () => handleSelection(index, option),
          disabled: option?.disabled
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
          className: `${_RadioModule.default['radio-container__label']}`,
          htmlFor: uuid?.[index] || window.btoa(option?.label),
          onClick: () => handleSelection(index, option),
          children: option?.label
        })]
      }), selectedOption === index && option?.element && /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        className: option?.label ? 'mt-3' : '',
        children: option.element
      })]
    }, index))
  });
}
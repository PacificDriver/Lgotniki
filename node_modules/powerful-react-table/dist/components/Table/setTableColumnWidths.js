"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _react = _interopRequireDefault(require("react"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const DEFAULT_WIDTH = 120;
const applyColumnWidths = function (children, headers) {
  let columnIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  let disableAutosize = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  if (disableAutosize) return [];
  const columnWidths = headers.map(() => 0);

  // Função para calcular a largura aproximada baseada no comprimento do texto
  const calculateTextWidth = text => {
    const fontSize = 14; // Supondo um tamanho de fonte padrão de 14px
    const avgCharWidth = fontSize * 0.6; // Aproximando cada caractere a 0.6x do tamanho da fonte
    const total = text.length * avgCharWidth;
    return total < DEFAULT_WIDTH ? DEFAULT_WIDTH : total;
  };

  // Função auxiliar para extrair texto de elementos JSX
  const getTextContent = content => {
    if (typeof content === 'string' || typeof content === 'number') {
      return content.toString(); // Se for string ou número, retorna o valor
    } else if (Array.isArray(content)) {
      // Se for um array de filhos, recursivamente acessa cada um
      return content.map(child => getTextContent(child)).join(' ');
    } else if (/*#__PURE__*/_react.default.isValidElement(content)) {
      // Se for um elemento JSX, tenta extrair os filhos
      return getTextContent(content?.props?.children);
    }
    return ''; // Se não for nenhum dos casos, retorna string vazia
  };

  // Recalcula a largura de uma coluna específica ou de todas
  const recalculateWidth = index => {
    // Calcula a largura do header específico
    const header = headers[index];
    const headerWidth = calculateTextWidth(header.title || '');

    // Calcula a maior largura entre o header e as células
    let maxColumnWidth = headerWidth;

    // Percorre as linhas (children) para calcular larguras dos <td>
    children.forEach(row => {
      const cell = row?.props?.children?.[index];
      const cellText = getTextContent(cell?.props?.children);
      const cellWidth = calculateTextWidth(cellText);
      if (cellWidth > maxColumnWidth) {
        maxColumnWidth = cellWidth;
      }
    });

    // Define a largura final da coluna recalculada
    columnWidths[index] = headers[index]?.width ? headers[index].width : maxColumnWidth;

    // Manipulação do DOM para aplicar a nova largura ao <th> e aos <td> correspondentes
    const headerElement = document.querySelectorAll('th')[index];
    if (headerElement) {
      headerElement.style.width = `${columnWidths[index]}px`;
    }
    const rows = document.querySelectorAll('tbody tr');
    rows.forEach(row => {
      const cell = row.children[index];
      if (cell) {
        cell.style.width = `${columnWidths[index]}px`;
      }
    });
  };
  if (columnIndex !== null) {
    // Recalcula apenas a coluna do índice fornecido
    recalculateWidth(columnIndex);
  } else {
    // Recalcula todas as colunas
    headers.forEach((_, index) => recalculateWidth(index));
    return columnWidths;
  }
};
var _default = exports.default = applyColumnWidths;
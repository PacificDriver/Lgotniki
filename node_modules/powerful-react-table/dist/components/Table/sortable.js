"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _react = require("react");
var _moment = _interopRequireDefault(require("moment"));
var _localeConfig = require("../../localeConfig");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const useSortable = () => {
  const [standardOrder, setStandardOrder] = (0, _react.useState)([]);
  const userLocale = (0, _localeConfig.getUserLocale)()?.locale;
  const removeMask = value => Number(value.replace(/[^0-9.-]+/g, "")?.replaceAll('.', '')?.replace(',', ''));
  const sortable = (column, filteredData, originalData) => {
    if (!standardOrder || standardOrder?.length !== filteredData?.length) {
      setStandardOrder(filteredData?.map(data => data?.props?.id));
    }
    const dataWithClassification = filteredData.map((parent, index) => {
      const childNodes = parent?.props?.children;
      let valueToClassify;
      childNodes?.forEach((child, childIndex) => {
        if (childIndex === column?.position) {
          const element = childNodes[childIndex]?.props?.children;
          valueToClassify = findInnerText(element);
          if (typeof valueToClassify === 'string' && valueToClassify?.match(/R$|£|€|\$/g)?.length === 1) {
            valueToClassify = removeMask(valueToClassify);
          }
        }
      });
      return {
        ...parent,
        valueToClassify
      };
    });
    switch (column?.sortType) {
      case 'down':
        return dataWithClassification.sort(sortAscending);
      case 'up':
        return dataWithClassification.sort(sortDescending);
      default:
        return filtersOriginalData(originalData);
    }
  };
  const findInnerText = element => {
    if (typeof element === 'string') return element;
    if (Array.isArray(element)) {
      for (let i = 0; i < element.length; i++) {
        const result = findInnerText(element[i]);
        if (result) return result;
      }
    }
    if (element?.props?.children) return findInnerText(element.props.children);
    return null;
  };
  const onlyNumbers = value => /^\d+$/.test(value);
  const onlyDates = value => {
    const date = value?.split('/');
    if (date?.length < 3) return false;
    if (userLocale === 'en-US') return (0, _moment.default)(`${date[2]}-${date[0]}-${date[1]}`).isValid();
    return (0, _moment.default)(date?.reverse().join('-')).isValid();
  };
  const convertToDate = value => {
    const date = value?.split('/');
    if (userLocale === 'en-US') return (0, _moment.default)(`${date[2]}-${date[0]}-${date[1]}`).valueOf();
    return (0, _moment.default)(date?.reverse().join('-'))?.valueOf();
  };
  const sortAscending = (a, b) => {
    if (onlyNumbers(a?.valueToClassify)) return a.valueToClassify - b.valueToClassify;
    if (onlyDates(a?.valueToClassify)) return convertToDate(a.valueToClassify) - convertToDate(b.valueToClassify);
    return a.valueToClassify > b.valueToClassify ? -1 : 1;
  };
  const sortDescending = (a, b) => {
    if (onlyNumbers(a.valueToClassify)) return b.valueToClassify - a.valueToClassify;
    if (onlyDates(a.valueToClassify)) return convertToDate(b.valueToClassify) - convertToDate(a.valueToClassify);
    return b.valueToClassify > a.valueToClassify ? -1 : 1;
  };
  const filtersOriginalData = originalData => {
    return originalData?.filter(data => standardOrder?.includes(data?.props?.id));
  };
  return {
    sortable
  };
};
var _default = exports.default = useSortable;